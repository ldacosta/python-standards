image: docker.io/condaforge/mambaforge:4.12.0-2

clone:
  depth: full  # Necessary for SonarCloud

definitions:
  caches:
    conda: /opt/conda/pkgs
    sonar: ~/.sonar/cache
  services:
    docker:
      memory: 2048  # Sonarcloud needs more than the default of 1024 MB to run
  format-lint-test: &format-lint-test
    name: Check formatting, linting and run unit tests
    caches:
      - conda  # defined above
    artifacts:
      - coverage.xml  # generated by inv test
    script:
      # Add jq to get auth file
      - apt update && apt install jq --yes
      - jq -n --arg domain happypackages.jfrog.io --arg username_password ${JFROG_USERNAME}:${JFROG_PASSWORD} '{($domain):($username_password)}' > auth.json
      # Update conda and install environment
      - mamba update mamba -y
      - mamba env update --name base --file environment.docker.yml
      - conda-lock install --name platypus-core --auth-file auth.json --mamba conda-linux-64.lock
      - mamba env update --name platypus-core --file environment.dev.yml
      - conda activate platypus-core
      # Run tests: todo, parallel with conda env as artifact
      - inv check-format
      - inv lint
      - inv test
      - inv benchmark
  conda-lock-check: &conda-lock-check
    name: Check that the conda-lock file is updated when environment.yml is updated
    condition:
      changesets:
        includePaths:
          - "environment.yml"
    script:
      # Fetch all branches in remote to compare
      - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
      # Check that both files are updated in the PR
      - if git diff-tree --name-only --quiet --exit-code $(git merge-base remotes/origin/${BITBUCKET_PR_DESTINATION_BRANCH} HEAD) HEAD -- conda-linux-64.lock; then echo 'Error - conda-linux-64.lock file not updated'; exit 1; fi
  sonarcloud-quality-check: &sonarcloud-quality-check
    name: Run sonarcloud code quality
    caches:
      - sonar
    script:
      - pipe: sonarsource/sonarcloud-scan:1.4.0
      - pipe: sonarsource/sonarcloud-quality-gate:0.1.6
    variables:
      EXTRA_ARGS: -Dsonar.coverage.jacoco.xmlReportPaths=coverage.xml
  test-docker-image: &test-docker-image
    name: Build and test the final docker image
    caches:
      - docker
    services:
      - docker
    size: 2x
    script:
      # Add jq and create auth file for building the conda image with the jfrog credentials and pass as secret to docker build
      - apt update && apt install jq --yes
      - jq -n --arg domain happypackages.jfrog.io --arg username_password ${JFROG_USERNAME}:${JFROG_PASSWORD} '{($domain):($username_password)}' > auth.json
      # Build with docker, note use buildkit way instead when supported on bitbucket
      - docker build . --tag platypus-core:$BITBUCKET_COMMIT
      #- DOCKER_BUILDKIT=1 docker build --secret id=auth,src=auth.json --tag platypus-core:$BITBUCKET_COMMIT .
      - ./test_docker.sh platypus-core:$BITBUCKET_COMMIT
  publish-docker-commit: &publish-docker-commit
    name: Publish docker image with git commit version
    caches:
      - docker
    services:
      - docker
    size: 2x
    script:
      # Add jq and create auth file for building the conda image with the jfrog credentials and pass as secret to docker build
      - apt update && apt install jq --yes
      - jq -n --arg domain happypackages.jfrog.io --arg username_password ${JFROG_USERNAME}:${JFROG_PASSWORD} '{($domain):($username_password)}' > auth.json
      # Build with docker, note use buildkit way instead when supported on bitbucket
      #- DOCKER_BUILDKIT=1 docker build --secret id=auth,src=auth.json --tag platypus-core:$BITBUCKET_COMMIT .
      - docker build . --tag happyregistry.azurecr.io/methods/wes/platypus-core:$BITBUCKET_COMMIT
      - echo $HAPPY_REGISTRY_PASSWORD_WORKSPACE | docker login --username $HAPPY_REGISTRY_USERNAME_WORKSPACE --password-stdin happyregistry.azurecr.io
      - docker push happyregistry.azurecr.io/methods/wes/platypus-core:$BITBUCKET_COMMIT
  publish-docker-tag: &publish-docker-tag
    name: Publish docker image with git tag version
    caches:
      - docker
    services:
      - docker
    size: 2x
    script:
      # Add jq and create auth file for building the conda image with the jfrog credentials and pass as secret to docker build
      - apt update && apt install jq --yes
      - jq -n --arg domain happypackages.jfrog.io --arg username_password ${JFROG_USERNAME}:${JFROG_PASSWORD} '{($domain):($username_password)}' > auth.json
      # Build with docker, note use buildkit way instead when supported on bitbucket
      #- DOCKER_BUILDKIT=1 docker build --secret id=auth,src=auth.json --tag platypus-core:$BITBUCKET_TAG .
      - docker build . --tag happyregistry.azurecr.io/methods/wes/platypus-core:$BITBUCKET_TAG
      - echo $HAPPY_REGISTRY_PASSWORD_WORKSPACE | docker login --username $HAPPY_REGISTRY_USERNAME_WORKSPACE --password-stdin happyregistry.azurecr.io
      - docker push happyregistry.azurecr.io/methods/wes/platypus-core:$BITBUCKET_TAG

pipelines:
  pull-requests:
    '**': # this runs as default for PRs from any branch not elsewhere defined
      - parallel:
        - step: *format-lint-test
        - step: *conda-lock-check
      - parallel:
        - step: *test-docker-image
        - step: *sonarcloud-quality-check
  branches:
    main:
      - step: *publish-docker-commit
  tags:
    '*':
      - step: *publish-docker-tag
